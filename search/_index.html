<!DOCTYPE html>
<html lang="en" >
 <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="description" content="Solve randomly generated word search puzzles.">
	<meta name="author" content="Andrew Ippoliti">
	<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=10.0;">
	<link rel="apple-touch-icon" href="image.png"/>  
	
    <title>Word Search Puzzle Generator</title>
	<style type="text/css">
		html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6{
			margin:0px;
			padding:0px;
			-webkit-text-size-adjust:none;
		}
		ul, li, ol, dl, dd, dt{
			list-style:none;
			padding:0px;
			margin:0px; 
		}
		a{ text-decoration:none; } 
		body {text-align: center; font-size: 24px; height: 1024px;}
		.PUZ-CON {position: relative;}
		div.WORD-SEARCH-PUZZLE {
			background: none;
			font-size: 42px;
			border: 0px solid #000;
			-moz-user-select:none;
			-o-user-select:none;
			-khtml-user-select:none;
			-webkit-user-select:none;
			-ms-user-select:none;
			user-select:none;
			position: fixed;
		}
		div.WORD-SEARCH-PUZZLE div {
			position: absolute;
			padding: 0px;
			margin: 0px;
			border: 0px;
			width: 48px;
			-moz-user-select:none;
			-o-user-select:none;
			-khtml-user-select:none;
			-webkit-user-select:none;
			-ms-user-select:none;
			user-select:none;
			background: none;
		}
		#JS-PASS {visibility:hidden;}
		@media screen {
			.WORD-LIST {
				font-size: 24px;
			}
			.WORD-LIST div { padding: 0px 16px;}
			.WORD-LIST div.WS-FOUND { text-decoration: line-through; }
			canvas {z-index: -1; position: absolute; top: 0px; left: 0px;}
			
			/* Horizontal 480x320px orientation */
			.c-hor {width: 480px; margin: auto;}
			.c-hor div.msg {position: absolute; top: 0px; left: 320px; width: 160px; height: 128px; }
			.c-hor div.WORD-LIST {position: absolute; top: 128px; left: 320px; width: 160px; }
			.c-hor div.WORD-SEARCH-PUZZLE {postion: absolute; top: 0px; left: 0px;}
			
			/* Veritcal 320x480px orientation */
			.c-ver {width: 320px; margin: auto;}
			.c-ver div.msg {position: absolute; top: 320px; left: 0px; width: 320px; height: 64px; }
			.c-ver div.WORD-LIST {position: absolute; top: 384px; left: 0px; width: 320px; }
			.c-ver div.WORD-SEARCH-PUZZLE {postion: absolute; top: 0px; left: 0px;}
		}
		
		/* Print only styles */
		@media print {
			canvas{ display: none; }
			.msg { display: none; }
			div.WORD-SEARCH-PUZZLE {
				background: none;
				font-size: 42px;
				border: 0px solid #000;
				-moz-user-select:none;
				-o-user-select:none;
				-khtml-user-select:none;
				-webkit-user-select:none;
				-ms-user-select:none;
				user-select:none;
				position: absolute;
			}
			body { height: 100%; }
		}
		
	</style>
 </head>
    <body><div id="container" style="visibility:hidden;" class="c-hor">
		<div id="puzzle" class="PUZ-CON"></div>
		<div id="JS-PASS">
			<div class="WORD-SEARCH-PUZZLE">
				<div id="JS-CELL-WIDTH"></div>
			</div>
		</div>
	</div>
	
<script type="text/javascript">
// Ippo's Code - (C) 2012 Andrew Ippoliti - http://acipo.com //
// WARNING: This code is pretty aweful...
// Use it at your own risk 
var WS_DOWN_CELL = "";
var WS_UP_CELL = "";
var WS_DATA = [];
function WS_TouchStart(e){
	// Get the event, if it wasn't passed.
	if(!e){ e = window.event; }
	// If we're given a target element, use it (W3C).
	if(e.target){     var target = e.target; }else
	// Otherwise try scrElement (IE).
	if(e.srcElement){ var target = e.srcElement; }
	// Remember the id of the element that was touched.
	WS_DOWN_CELL = target.id;
	
	// Prevent highlighting and whatnot so the user can 'touch' and  drag.
	e.preventDefault();
	return false;
}
function WS_TouchMove(e){
	//if (e.touches.length > 1) return; //allow default multi-touch gestures to work

	var t = e.changedTouches[0];
	
	var x = parseInt(t.pageX);
	var y = parseInt(t.pageY);
	var baseID = ""+WS_DOWN_CELL.split("_")[0];
	//console.info("Base cell id: "+baseID);
	var baseObj = document.getElementById(baseID+"_0_0");
	//find the position of the base element on the page
	var baseX = parseInt(baseObj.offsetLeft);; 
	var baseY = parseInt(baseObj.offsetTop);
	while(baseObj.offsetParent != null){
		baseObj = baseObj.offsetParent;
		baseX += parseInt(baseObj.offsetLeft);
		baseY += parseInt(baseObj.offsetTop);
	}
	var W = parseInt(document.getElementById("JS-CELL-WIDTH").offsetWidth);
	//var H = parseInt(document.getElementById("JS-CELL-WIDTH").offsetHeight);
	//get the currently selected cell index
	var xi = Math.floor((x-baseX)/W);
	var yi = Math.floor((y-baseY)/W);
	WS_UP_CELL = ""+baseID + "_"+xi+"_"+yi;
	WS_HandleHover(WS_DOWN_CELL,WS_UP_CELL);
	e.preventDefault();
	return false;
}
function WS_MouseMove(e){
	//var t = e.changedTouches.touches[0];
	var t = e;
	var x = parseInt(t.pageX);
	//console.info("e.clientX: "+t.clientX);
	var y = parseInt(t.pageY);
	//find the 0,0 cell to use as a position reference
	//console.info("Down cell id: "+WS_DOWN_CELL);
	if(WS_DOWN_CELL == ""){return;}
	var baseID = ""+WS_DOWN_CELL.split("_")[0];
	//console.info("Base cell id: "+baseID);
	var baseObj = document.getElementById(baseID+"_0_0");
	//find the position of the base element on the page
	var baseX = parseInt(baseObj.offsetLeft);; 
	var baseY = parseInt(baseObj.offsetTop);
	while(baseObj.offsetParent != null){
		baseObj = baseObj.offsetParent;
		baseX += parseInt(baseObj.offsetLeft);
		baseY += parseInt(baseObj.offsetTop);
	}
	var W = parseInt(document.getElementById("JS-CELL-WIDTH").offsetWidth);
	//var H = parseInt(document.getElementById("JS-CELL-WIDTH").offsetHeight);
	//get the currently selected cell index
	var xi = Math.floor((x-baseX)/W);
	var yi = Math.floor((y-baseY)/W);
	WS_UP_CELL = ""+baseID + "_"+xi+"_"+yi;
	//console.info("Up cell id: "+WS_UP_CELL);
	//check to make sure it's right:
	var check = document.getElementById(WS_UP_CELL);
	if(Math.abs(check.clientX - x) > W || Math.abs(check.clientY - y) > W){
		alert("Error?");
	}
	WS_HandleHover(WS_DOWN_CELL,WS_UP_CELL);
	return false;
}
function WS_TouchEnd(e){
	WS_CheckFoundWord(WS_DOWN_CELL,WS_UP_CELL);
	//reset
	WS_DOWN_CELL = "";
	WS_UP_CELL = "";
}

function WS_MouseDown(CellID){WS_DOWN_CELL = CellID;return false;}
function WS_MouseOver(CellID){
	WS_UP_CELL = CellID;
	WS_HandleHover(WS_DOWN_CELL,WS_UP_CELL);
	return false;
}
function WS_MouseUp(){
	WS_CheckFoundWord(WS_DOWN_CELL,WS_UP_CELL);
	//reset
	WS_DOWN_CELL = "";
	WS_UP_CELL = "";
	return false;
}
function WS_CircleWord(CTX,Xs,Ys,Xe,Ye,W,C){
	Ys += 2;
	Ye += 2;
	//compute the 'angle' the line is going
	var dx = Xe-Xs;
	var dy = Ye-Ys;
	var lineDir = Math.atan2(dy,dx);
	//add 90 to get a perpendicular line
	var perpStart = lineDir + Math.PI/2;
	var perpEnd = perpStart + Math.PI;
	//the 'radius' will be some fraction of the parameter W
	var r = W/3;
	//setup canvas parameters
	CTX.lineWidth = 2;
	CTX.lineCap = "round";
	CTX.lineJoin = "round";
	//c2D.miterLimit = value
	CTX.strokeStyle = C;
	CTX.beginPath();
	CTX.moveTo(Xs+r*Math.cos(perpStart),Ys+r*Math.sin(perpStart));
	CTX.lineTo(Xe+r*Math.cos(perpStart),Ye+r*Math.sin(perpStart));
	CTX.moveTo(Xs+r*Math.cos(perpEnd),Ys+r*Math.sin(perpEnd));
	CTX.lineTo(Xe+r*Math.cos(perpEnd),Ye+r*Math.sin(perpEnd));
	CTX.stroke();
	CTX.beginPath();
	CTX.arc(Xs,Ys,r,perpStart,perpEnd,0);
	CTX.stroke();
	CTX.beginPath();
	CTX.arc(Xe,Ye,r,perpStart,perpEnd,1);
	CTX.stroke();
	return;
}
function WS_HasFoundAll(PuzID){
	var listDOM = document.getElementById(PuzID+"_LIST");
	var tds = listDOM.getElementsByTagName("div");
	var i=tds.length;
	while(i--){
		if(tds[i].className != "WS-FOUND"){return 0;}
	}
	return 1;
}
function WS_HandleHover(DownID,UpID){
	//table cell id's have the form:
	//ID_X_Y
	var DownData = DownID.split("_");
	var wsXDown = parseInt(DownData[1]);
	var wsYDown = parseInt(DownData[2]);
	var wsTableDown = DownData[0];
	var UpData = UpID.split("_");
	var wsXUp = parseInt(UpData[1]);
	var wsYUp = parseInt(UpData[2]);
	var wsTableUp = UpData[0];
	//if the events occured on 2 different tables then ignore
	if(wsTableUp != wsTableDown){
		//console.info("Different Tables");
		return 0;
	}
	var c2D = document.getElementById(wsTableUp+"_HOVER").getContext("2d");
	var cellW = parseInt(document.getElementById("JS-CELL-WIDTH").offsetWidth);
	var drawXS = (cellW/2) + (wsXDown * cellW);
	var drawYS = (cellW/2) + (wsYDown * cellW);
	var drawXE = (cellW/2) + (wsXUp * cellW);
	var drawYE = (cellW/2) + (wsYUp * cellW);
	c2D.clearRect(0,0,9999,9999);
	WS_CircleWord(c2D,drawXS,drawYS,drawXE,drawYE,cellW,"#DD0000");
}
function WS_CheckFoundWord(DownID,UpID){
	//console.info('Start:'+DownID);
	//console.info('End:'+UpID);
	//table cell id's have the form:
	//ID_X_Y
	var DownData = DownID.split("_");
	var wsXDown = parseInt(DownData[1]);
	var wsYDown = parseInt(DownData[2]);
	var wsTableDown = DownData[0];
	//console.info(UpID);
	var UpData = UpID.split("_");
	var wsXUp = parseInt(UpData[1]);
	var wsYUp = parseInt(UpData[2]);
	var wsTableUp = UpData[0];
	//if the events occured on 2 different tables then ignore
	if(wsTableUp != wsTableDown){
		//console.info("Different Tables");
		document.getElementById(wsTableUp+"_MSG").innerHTML = "Please try and stay in one puzzle.";
		return 0;
	}
	//console.info("Using table: "+wsTableUp);
	//compute delta x and delta y
	var dx = wsXUp - wsXDown;
	var dy = wsYUp - wsYDown;
	//console.info("DX: "+dx+", DY: "+dy);
	//if we haven't moved
	if(dx==0 && dy==0){
		//console.info("Haven't moved");
		document.getElementById(wsTableUp+"_MSG").innerHTML = "Don't just click one letter. Press, drag, release.";
		return 0;
	}
	//if both are not 0 then we're going completely diagonally
	if(dx!=0 && dy!=0){
		//if the slope is 45* in any direction then ignore
		if(Math.abs(dx) != Math.abs(dy)){
			//console.info("Not 45*");
			document.getElementById(wsTableUp+"_MSG").innerHTML = "Diagonal lines must be 45&deg;. Please try again.";
			return 0;
		}
	}
	//text-decoration: line-through
	//collect the letters from the table
	var x = wsXDown;
	var y = wsYDown;
	var selectedWord = "";
	var mx=0;
	if(dx>0){mx= 1;}else
	if(dx<0){mx=-1;}
	var my=0;
	if(dy>0){my= 1;}else
	if(dy<0){my=-1;}
	while(x != wsXUp || y != wsYUp){
		selectedWord += document.getElementById(wsTableUp+"_"+x+"_"+y).innerHTML;
		x += mx;
		y += my;
	}
	selectedWord += document.getElementById(wsTableUp+"_"+x+"_"+y).innerHTML;
	//console.info("You selected: "+selectedWord);
	//check to see if the word is in the lst of words
	var listDOM = document.getElementById(wsTableUp+"_LIST");
	var tds = listDOM.getElementsByTagName("div");
	var i=tds.length;
	while(i--){
		if(tds[i].innerHTML == selectedWord){
			tds[i].className = "WS-FOUND";
			//console.info("You found it");
			//style the found cells
			var dir = "NN";
			if(mx== 0 && my== 1){dir = "SS";}else
			if(mx== 0 && my==-1){dir = "NN";}else
			if(mx== 1 && my== 0){dir = "EE";}else
			if(mx==-1 && my== 0){dir = "WW";}else
			if(mx== 1 && my== 1){dir = "SE";}else
			if(mx== 1 && my==-1){dir = "NE";}else
			if(mx==-1 && my== 1){dir = "SW";}else
			if(mx==-1 && my==-1){dir = "NW";}
			x = wsXDown;
			y = wsYDown;
			document.getElementById(wsTableUp+"_"+x+"_"+y).className += " "+dir+"_STR";
			x += mx; y += my;
			while(x != wsXUp || y != wsYUp){
				document.getElementById(wsTableUp+"_"+x+"_"+y).className += " "+dir+"_MID";
				x += mx;
				y += my;
			}
			document.getElementById(wsTableUp+"_"+x+"_"+y).className += " "+dir+"_END";
			//draw a circle or line on the canvas
			var c2D = document.getElementById(wsTableUp+"_CANVAS").getContext("2d");
			var cellW = parseInt(document.getElementById("JS-CELL-WIDTH").offsetWidth);
			var drawXS = (cellW/2) + (wsXDown * cellW);
			var drawYS = (cellW/2) + (wsYDown * cellW);
			var drawXE = (cellW/2) + (wsXUp * cellW);
			var drawYE = (cellW/2) + (wsYUp * cellW);
			WS_CircleWord(c2D,drawXS,drawYS,drawXE,drawYE,cellW,"#999999");
			document.getElementById(wsTableUp+"_MSG").innerHTML = "You Found: '"+selectedWord+"'";
			if(WS_HasFoundAll(wsTableUp)==1){
				document.getElementById(wsTableUp+"_MSG").innerHTML = "Congratulations! You found everything.";
			}
			return 1;
		}
	}
	//we didn't find it
	document.getElementById(wsTableUp+"_MSG").innerHTML = "You Found: '"+selectedWord+"' but it is not in the word list...";
	return 0;
}
function WS_CheckLocation(Word,PuzzleArray,Width,Height,X,Y,Dir,Write){
	var l = Word.length;
	var dx, dy;
	switch(Dir){
		case 128: dx = 1; dy = 0; break; // to the right
		case   1: dx = 1; dy =-1; break; // right & up
		case   2: dx = 0; dy =-1; break; // up
		case   4: dx =-1; dy =-1; break; // left & up
		case   8: dx =-1; dy = 0; break; // left
		case  16: dx =-1; dy = 1; break; // left & down
		case  32: dx = 0; dy = 1; break; // down
		case  64: dx = 1; dy = 1; break; // down & right
	}
	//make sure the word fits within the bounds of the puzzle
	if(X+l*dx > Width){return null;}
	if(X+l*dx < 0){return null;}
	if(Y+l*dy > Height){return null;}
	if(Y+l*dy < 0){return null;}
	//check if each character can go in each spot
	var x=X; var y=Y;
	var i,spot;
	for(i=0; i<l; i++){
		spot = PuzzleArray[y*Width+x];
		//if the letter has been decided already and the characters
		//do not match then the word cannot go here
		if(spot.SET != 0 && spot.LET != Word.charAt(i)){return null;}
		//if given the option write the word there
		if(Write==1){
			// Note: spot.SET|Dir -> this is because multiple letters will be 
			// placed at this spot so we want to record all directions
			PuzzleArray[y*Width+x] = {X:x, Y:y, SET:(spot.SET|Dir), LET: Word.charAt(i)};
		}
		x += dx;
		y += dy;
	}
	return {word:Word,x:X,y:Y,dir:Dir};
}

function WS_PuzzleAddWord(Word,PuzzleArray,Width,Height,AllowedDirections){
	var dirs = [128,1,2,4,8,16,32,64];
	var locations = [];
	var i,j,k, score;
	for(i=0; i<Width; i+=1){
		for(j=0; j<Height; j+=1){
			for(k=0; k<8; k++){
				if((AllowedDirections & dirs[k]) ==  dirs[k]){
					var placed = WS_CheckLocation(Word,PuzzleArray,Width,Height,i,j,dirs[k],0);
					if(placed != null){
						score += 1;
						locations[locations.length] = {X:i, Y:j, D: dirs[k]};
					}
				}
			}
		}
	}
	//console.info(Word+' has '+locations.length+' possible positions');
	//if we haven't found a spot for the word exit
	if(locations.length == 0){return null;}
	//locations has all of the possible locations that the word can fit
	//pick a random location & put the word there
	var place = Math.round(RANDOM.Random()*(locations.length-1));
	//console.info("Using the "+place+"th location");
	var loc = locations[place];
	//write the word to the spot
	return WS_CheckLocation(Word,PuzzleArray,Width,Height,loc.X,loc.Y,loc.D,1);
}
function WS_CreatePuzzle(ArrayOfWords,Width,Height,AllowedDirections,maxWords){
/// Creates and returns a new puzzle object.
	var PUZZLE = {GRID:[],WORDS:[],ANSWERS:[]};
	var i,j;
	// Initialize the puzzle array to blank values.
	for(i=0; i<Height; i+=1){
		for(j=0; j<Width; j+=1){
			PUZZLE.GRID[i*Width+j] = {X:j, Y:i, SET:0, LET: '-'};
		}
	}
	// Add words to puzzle.
	var wordsAdded = 0;
	var wordCnt = ArrayOfWords.length;
	for(i=0; i<wordCnt; i++){
		// If we add a word to the puzzle
		var answer = WS_PuzzleAddWord(ArrayOfWords[i],PUZZLE.GRID,Width,Height,AllowedDirections);
		if(answer!=null){
			//console.info(answer);
			// Remember the word that it added.
			PUZZLE.WORDS[PUZZLE.WORDS.length] = ArrayOfWords[i];
			PUZZLE.ANSWERS[PUZZLE.ANSWERS.length] = answer;
			// Make sure we don't add too many words.
			wordsAdded += 1;
			if(wordsAdded >= maxWords){
				i=wordCnt;
			}
		}
	}
	// Return the puzzle object.
	return PUZZLE;
}
function WS_GenerateHTML(ID,Puzzle,Width,Height,RndChrArr){
/// Takes a puzzle object and creates the HTML code string to draw it.
// ID is the html id we will give to the puzzle container node.
// Puzzle in the puzzle object to be converted.
// Width is the number of characters that horizontally fit in the puzzle.
// Height is the number of characters that vertically fit in the puzzle.
// RndCharArr is a string of characters that will be used to fill blanks.
	var i, j;
	// Use a hidden object on the page to determine the width of a letter.
	var cellW = parseInt(document.getElementById("JS-CELL-WIDTH").offsetWidth);
	var HTML = "<div class='WORD-SEARCH-PUZZLE' id='"+ID+"' "
	HTML += "style='width:"+(cellW*Width)+"px; "
	HTML += "height:"+(cellW*Height)+"px;' >\n";
	// Create Canvas to draw "circles/lines" through found words.
	HTML += "<canvas id='"+ID+"_CANVAS' width="+(cellW*Width);
	HTML += " height="+(cellW*Height)+"></canvas>\n";
	// Create anohter canvas to draw temp selection.
	HTML += "<canvas id='"+ID+"_HOVER' width="+(cellW*Width);
	HTML += " height="+(cellW*Height)+"></canvas>\n";
	//create letter 'cells'
	var spot, id;
	for(i=0; i<Height; i++){
		//HTML += "\t<div class='row'>";
		for(j=0; j<Width; j++){
			id = ID+"_"+j+"_"+i;
			HTML += "<div id='"+id+"' "
			HTML += "onmousedown='WS_MouseDown(\""+id+"\")' ";
			HTML += "onmouseup='WS_MouseUp(\""+id+"\")' ";
			HTML += "onmouseover='WS_MouseOver(\""+id+"\")' ";
			//HTML += "onmouseover='WS_TouchMove' ";
			//for touch events, the end event corresponds to the start event id
			//HTML += "ontouchstart ='WS_MouseDown(\""+id+"\"); ' ";
			//HTML += "ontouchmove ='WS_TouchMove' ";
			//HTML += "ontouchend ='WS_TouchEnd' ";
			//
			HTML += "style='top:"+(cellW*i)+"px; ";
			HTML += "left:"+(cellW*j)+"px;' ";
			HTML += ">";
			spot = Puzzle.GRID[i*Width+j];
			//if the spot hasn't been set
			if(spot.SET == 0){
				//put a random character there
				HTML+=RndChrArr.charAt(RANDOM.BetweenInt(0,RndChrArr.length));
			}else{
				HTML += spot.LET;
			}
			HTML += "</div>";
		}
		//HTML += "</div>\n";
		HTML += "\n";
	}
	HTML += "</div>\n";
	//Create a spot where we can alert the user
	HTML += "<div class='msg' id='"+ID+"_MSG'>Find a word!</div>\n";
	//Create list of words to find
	HTML += "<div class='WORD-LIST' id='"+ID+"_LIST'>\n";
	var wordCnt = Puzzle.WORDS.length;
	for(i=0; i<wordCnt; i++){
		HTML += "<div id='"+ID+"_LIST_"+i+"' ";
		HTML += "onclick='WS_ShowAnswer("+i+")' ";
		HTML += ">";
		HTML += Puzzle.WORDS[i];
		HTML += "</div>\n";
	}
	HTML += "</div>\n";
	WS_DATA[WS_DATA.length] = {ID:ID, PUZ:Puzzle, W:Width, H:Height};
	return HTML;
}
function WS_ShowAnswer(index){
	//console.info(WS.PUZZLE);
	if(WS.MODE != 'help'){return;}
	var answer = WS.PUZZLE.ANSWERS[index];
	var x = answer.x;
	var y = answer.y;
	var downId = WS.ID+"_"+ x +"_"+ y;
	//console.info('Start:'+downId);
	var l = answer.word.length-1;
	var dx, dy;
	switch(answer.dir){
		case 128: dx = 1; dy = 0; break; // to the right
		case   1: dx = 1; dy =-1; break; // right & up
		case   2: dx = 0; dy =-1; break; // up
		case   4: dx =-1; dy =-1; break; // left & up
		case   8: dx =-1; dy = 0; break; // left
		case  16: dx =-1; dy = 1; break; // left & down
		case  32: dx = 0; dy = 1; break; // down
		case  64: dx = 1; dy = 1; break; // down & right
	}
	x += dx*l;
	y += dy*l;
	var upId = WS.ID+"_"+ x +"_"+ y;
	//console.info('End:'+upId);
	WS_UP_CELL = upId;
	WS_DOWN_CELL = downId;
	WS_CheckFoundWord(WS_DOWN_CELL,WS_UP_CELL);
	WS_DOWN_CELL = "";
	WS_UP_CELL = "";
}
function UI_Orient(){
	switch (window.orientation) {
	case   0: //portrait                       -> menu/home at bottom
		document.getElementById("container").className = "c-ver";
		break;
	case -90: //clockwise turn    90* -> [  |] -> menu/home on right
		document.getElementById("container").className = "c-hor";
		break;
	case  90: //counter clockwise 90* -> [|  ] -> menu/home on left
		document.getElementById("container").className = "c-hor";
		break;
	case 180: //upside down portrait           -> menu/home at top
		document.getElementById("container").className = "c-ver";
		break;
	}
}
function GetUrlParms(){
	/// Parses the URL for parameters and returns an array of key-value pairs
	// URL parameters begin after the '?' in the URL.
	var startLocation = window.location.href.indexOf('?');
	// We may not have any URL parameters.
	if( startLocation == -1 ){ return null; }
	// We do not care about the location part of the URL.
	var parmString = window.location.href.slice(startLocation + 1);
	// Each key/value pair is separated by an '&'.
	var varStrings = parmString.split('&');
	// We need to iterate over each key/value string.
	var l = varStrings.length;
	var variables = {};
	for(var i=0; i<l; i+=1){
		// Key/value strings have the form: key=value
		var tmp = varStrings[i].split('=');
		// We need to unescape the strings because they be encoded as follows:
		// "hello world" -> hello+world
		// or certain charactes are encoded as their ascii value: %20 %da
		// We also convert the key to lower case so the program can always
		// access via the lower case key.
		variables[unescape(tmp[0]).toLowerCase()] = unescape(tmp[1]);
	}
	return variables;
}
// Random numbers
RANDOM = (function(){
	var Seed = Math.floor(Math.random()*4294967296);
	var Current = Seed;
	function SetSeed(aSeed){ Seed = aSeed; Current = aSeed; }
	function GetSeed(){ return Seed; }
	function GetCurrent(){ return Current; }
	function BetweenInt(aMin,aMax){
		Current = (Current * 1664525 + 1013904223)%4294967296;
		return aMin + Math.floor((Current/4294967296)*aMax);
	}
	function BetweenFloat(aMin,aMax){
		Current = (Current * 1664525 + 1013904223)%4294967296;
		return aMin + (Current/4294967296)*aMax;
	}
	function Random(){
		Current = ((Current * 1664525 + 1013904223)%4294967296);
		return Current/4294967296;
	}
	return {
		SetSeed: SetSeed,
		GetSeed: GetSeed,
		GetCurrent: GetCurrent,
		BetweenInt: BetweenInt,
		BetweenFloat: BetweenFloat,
		Random: Random
	}
})();
// Word Search Parameters and Global Storage
WS = {
	// Setup/creation parameters
	WORD_LIST: null,
	WIDTH: 6,
	HEIGHT: 6,
	MAX: 6*6,
	SEED: RANDOM.GetSeed(),
	MODE: 'question',
	DIRECTIONS: 128|1|2|4|8|16|32|64,
	REPLACEMENT: 'abcdefghijklmnopqrstuvwxyz',
	// Puzzle storage elements/parameters
	ID: 'P1',
	PUZZLE: null,
	CODE: ''
};
onload = function(){
	var gUrlParms = GetUrlParms();
	// URL PARAMETERS:
	// WORDS: a comma seperated list of words
	// WIDTH: the width of the puzzle in number of characters
	// HEIGHT: the height of the puzzle in number of characters
	// MAX: the maximum number of words to show
	// SEED: an integer that will seed the random number generation
	// MODE: the method that the game should be run in
	//      game - does not show answers when a word from the list is clicked
	//      help - shows the answer when a word from the list is clicked
	// DIRS: a comma speerated list of allowed word directions
	//   By default all directions are allowed, for 'regular' left to right
	//   reading just enable 'E' east, 'W' west is 'backwards', 
	//   ALL, N, S, E, W, NE, NW, SE, SW
	
	var WORD_LIST = null;
	var WIDTH = 6;
	var HEIGHT = 6;
	var MAX = WIDTH*HEIGHT;
	var RANDOM_SEED = RANDOM.GetSeed();
	var MODE = 'question';
	var DIRECTIONS = 128|1|2|4|8|16|32|64;
	
	// Try to load URL parameters.
	if(gUrlParms != null){
		if(gUrlParms["words"]!=null){
			WS.WORD_LIST = gUrlParms["words"].split(',');
		}
		if(gUrlParms["width"]!=null){
			WS.WIDTH = parseInt(gUrlParms["width"]);
		}
		if(gUrlParms["height"]!=null){
			WS.HEIGHT = parseInt(gUrlParms["height"]);
		}
		if(gUrlParms["max"]!=null){
			WS.MAX = parseInt(gUrlParms["max"]);
		}else{
			WS.MAX = WIDTH*HEIGHT;
		}
		if(gUrlParms["seed"]!=null){
			WS.SEED = parseInt(gUrlParms["seed"]);
		}
		if(gUrlParms["mode"]!=null){
			var mode = gUrlParms["mode"].toLowerCase();
			if(mode == 'questions' || mode == 'question' || mode == 'game' ||
					mode == 'search' || mode == 'find' || mode == 'puzzle'){
				WS.MODE = 'find';
			}
			if(mode == 'answer' || mode == 'answers' || mode == 'solution' ||
					mode == 'solutions' || mode == 'found' ||
					mode == 'done' || mode == 'help' || mode == 'hint'){
				WS.MODE = 'help';
			}
		}
		if(gUrlParms["dirs"]!=null){
			var caps = gUrlParms["dirs"].toUpperCase();
			if(caps.indexOf('ALL') > -1){
				var dirNum = 128|1|2|4|8|16|32|64;
			}else{
				var dirs = caps.split('+');
				var nDirs = dirs.length;
				var dirNum = 0;
				for(var i=0; i<nDirs; i+=1){
					var iDir = dirs[i];
					if(iDir == 'E'){ dirNum |= 128; }
					else if(iDir == 'NE' || iDir == 'EN'){ dirNum |= 1; }
					else if(iDir == 'N'){ dirNum |= 2; }
					else if(iDir == 'NW' || iDir == 'WN'){ dirNum |= 4; }
					else if(iDir == 'W'){ dirNum |= 8; }
					else if(iDir == 'SW' || iDir == 'WS'){ dirNum |= 16; }
					else if(iDir == 'S'){ dirNum |= 32; }
					else if(iDir == 'SE' || iDir == 'ES'){ dirNum |= 64; }
				}
			}
			WS.DIRECTIONS = dirNum;
		}
	}
	RANDOM.SetSeed(WS.SEED);
	// If we're not supplied with a word list.
	if(WS.WORD_LIST == null){
		// Load a long list of words 
		WS.WORD_LIST = "word1,word2,word3,word4"
		// shuffle the word list
		var l = WS.WORD_LIST.length/2;
		for(var i=0; i<l; i+=1){
			var index1 = i;
			var index2 = Math.floor(RANDOM.Random()*l);
			var word1 = WS.WORD_LIST[index1];
			var word2 = WS.WORD_LIST[index2];
			WS.WORD_LIST[index2] = word1;
			WS.WORD_LIST[index1] = word2;
		}
	}
	
	
	WS.ID = "P1";
	WS.PUZZLE = WS_CreatePuzzle(WS.WORD_LIST,WS.WIDTH,WS.HEIGHT,WS.DIRECTIONS,WS.MAX);
	WS.CODE = WS_GenerateHTML(WS.ID,WS.PUZZLE,WS.WIDTH,WS.HEIGHT,WS.REPLACEMENT);
	document.getElementById("puzzle").innerHTML = WS.CODE;
	//add events
	var i=0; var j=0; var o=null;
	for(i=0; i<WS.WIDTH; i++){
		for(j=0; j<WS.HEIGHT; j++){
			o = document.getElementById(WS.ID+"_"+i+"_"+j);
			//o.onmouseover = WS_MouseMove;
			o.ontouchmove = WS_TouchMove;
			//o.onmouseup = function(a){return function(a){WS_MouseUp(a);}}(PID+"_"+i+"_"+j);
			//o.onmouseup = WS_MouseUp;
			//o.ontouchend = WS_TouchEnd;
		}
	}
	document.getElementById(WS.ID).ontouchstart = WS_TouchStart;
	document.getElementById(WS.ID).ontouchmove = WS_TouchMove;
	document.getElementById(WS.ID).ontouchend = WS_TouchEnd;
	UI_Orient();
	document.getElementById("container").style.visibility = "visible";
	window.scrollTo(0, 1); //scroll to the bottom hide the location bar  
}
onorientationchange = function(){UI_Orient();};

</script>
</body>
</html>